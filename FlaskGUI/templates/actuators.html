<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draggable Buttons</title>
    <style>
        body{
            /*makes everything unselectable, DO NOT REMOVE, buttons will drag while locked if selected, I do not know why :(*/
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #messageContainer{
            position: absolute;
            right: 0%;
            text-align: center;
            width: 12vw;
        }
        #backgroundContainer {
            z-index:-1;
            height: 100vh;
            width: 100vw;
            position: fixed;

            background-image: url("{{ url_for('static', filename='HTS_PandID.png') }}");
            background-size: contain; 
            background-repeat: no-repeat;
            background-origin: content-box;
            background-position: center center;
        }
        .collapsible-menu label {
            display: block;
            cursor: pointer;
            background-color: antiquewhite;
            text-align: center;
            width: 10vw;
            padding: 0 10px 5px 10px;
        }
        input#menu {
            display: none;
        }
        .guiControlButtonsContainer {
            width: 10vw;
            max-height: 0;
            overflow: hidden;
            padding: 0 10px 0 10px;
            background-color:antiquewhite;
            cursor: pointer;
            align-items: center;
        }
        #guiControlButtons{
            position: relative;
            width: 10vw;
            padding: 10px 10px;
            margin-bottom: 10px;
        }
        input:checked ~ .guiControlButtonsContainer {
            max-height: 100%;
        }
        .draggable {
            max-width: 150px;
            padding: 2px 2px;

            position: absolute;

            cursor: move;
            pointer-events: auto;
            color: black;
            background-color:black;
            border: solid;
            align-items: center;
            
        }
        .onButtons{
            position: relative;
            width:50%;
            float: left;
            background-color: white;
        }
        .offButtons{
            position: relative;
            width:50%;
            float: left;
            background-color: white;
        }
        #buttonNames{
            position: relative;
            color: white;
            text-align: center;
        }
        .locked {
            cursor: pointer;
        }
        
    </style>
</head>
<body>

<form method="post">
    {% for button in actuator_buttons %}
        <div id="{{ button }}" class="draggable" draggable="true">
            <legend id="buttonNames">{{button[5]}}</legend>
            <div id="{{ button[5], 'on' }}" class = "onButtons" onclick="buttonClicked(id)" >On</div>
            <div id="{{ button[5], 'off' }}" class = "offButtons" onclick="buttonClicked(id)" >Off</div> 
        </div>
    {% endfor %}
</form>

<div id="backgroundContainer"></div>
<div id="messageContainer"></div>
<div class="collapsible-menu">
    <input type="checkbox" id="menu">
    <label for="menu">Menu</label>
    <div class="guiControlButtonsContainer">
        <button id="guiControlButtons" onclick="submitCoordinates()">Submit Coordinates</button>
        <button id="guiControlButtons" onclick="getCoordinates(false)">Get Coordinates</button>
        <button id="guiControlButtons" onclick="lockButtons()">Lock Buttons</button>
        <button id="guiControlButtons" onclick="unlockButtons()">Unlock Buttons</button>
    </div>
</div>


<script>
    
    document.addEventListener("DOMContentLoaded", function () {
        // Fetch coordinates when the page is loaded
        getCoordinates(true);
        
        let draggableElements = document.querySelectorAll('.draggable');
        let isLocked = false;

        // TODO: a proper way of locking cuz running this function is kinda stupid, GPT wrote this and idk how it works
        lockButtons()

        draggableElements.forEach(function (element) {
            element.addEventListener('dragstart', function (e) {
                if (isLocked) {
                    e.preventDefault(); // Prevent dragging when locked
                    return;
                }
                e.dataTransfer.setData('text/plain', element.id);
            });
        });

        document.addEventListener('dragover', function (e) {
            e.preventDefault();
        });

        document.addEventListener('drop', function (e) {
            e.preventDefault();
            if (isLocked) {
                return; // Ignore drop when locked
            }
            let data = e.dataTransfer.getData('text/plain');
            let draggedElement = document.getElementById(data);

            let offsetX = e.clientX - draggedElement.offsetWidth / 2;
            let offsetY = e.clientY - draggedElement.offsetHeight / 2;

            draggedElement.style.left = offsetX + 'px';
            draggedElement.style.top = offsetY + 'px';
        });
    });

    function buttonClicked(id){
        // when we unlock buttons we want to ignore any accidential clicks
        if (!isLocked){
            return;
        }
        // Make a POST request to the Flask server with the button ID
        fetch('/actuators', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ id: id }),
        })
        .then(response => response.json())
        .then(data => {
            // Handle the response from the server if needed
            console.log(data);
        })
        .catch(error => console.error('Error:', error));
    }

    function submitCoordinates() {
        textprompt="tim hates linux"
            while(true){
            let confirmationPhrase = prompt("Type 'tim hates linux' to confirm");
            if (confirmationPhrase === textprompt) {

                let draggableElements = document.querySelectorAll('.draggable');
                let coordinates = [];

                draggableElements.forEach(function (element) {
                    let rect = element.getBoundingClientRect();
                    coordinates.push({ id: element.id, x: rect.left, y: rect.top });
                });

                // Send coordinates to Flask
                sendDataToFlask(coordinates);
                return;

            } else if (confirmationPhrase === null) {
                return; //user clicked cancel
                
            } else {
                alert("Confirmation failed. Incorrect phrase.");
            }
        }
    }

    function sendDataToFlask(coordinates) {
        fetch('/update_coordinates', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ coordinates: coordinates }),
        })
            .then(response => response.json())
            .then(data => console.log(data))
            .catch(error => console.error('Error:', error));
    }

    function getCoordinates(initial_load) {
        textprompt="tim hates linux"
        while(true){
            if(!initial_load){
                confirmationPhrase = prompt("Type 'tim hates linux' to confirm");
            } else {
                confirmationPhrase = textprompt;
            }

            console.log(confirmationPhrase);
            if (confirmationPhrase === textprompt) {

                fetch('/get_coordinates')
                    .then(response => response.json())
                    .then(data => {
                        let coordinates = data.coordinates;
                        console.log("Coordinates:", coordinates);

                        // Place the buttons at the fetched coordinates
                        coordinates.forEach(coord => {
                            let button = document.getElementById(coord.id);
                            if (button) {
                                button.style.left = coord.x + 'px';
                                button.style.top = coord.y + 'px';
                            }
                        });
                    })
                    .catch(error => console.error('Error:', error));
                return;

            } else if (confirmationPhrase === null) {
                return; //user clicked cancel
                
            } else {
                alert("Confirmation failed. Incorrect phrase.");
            }
        }
    }

    function lockButtons() {
        let draggableElements = document.querySelectorAll('.draggable');
        draggableElements.forEach(function (element) {
            element.classList.add('locked');
            element.draggable = false;
        });
        isLocked = true;
        messageContainer.innerText = "Buttons are LOCKED";
    }

    function unlockButtons() {
        let draggableElements = document.querySelectorAll('.draggable');
        draggableElements.forEach(function (element) {
            element.classList.remove('locked');
            element.draggable = true;
        });
        isLocked = false;
        messageContainer.innerText = "Buttons are UNLOCKED";
    }
</script>

</body>
</html>
